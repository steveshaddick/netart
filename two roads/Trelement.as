import mx.transitions.Tween;import mx.transitions.easing.*;class Trelement{		public var doneSlide:Boolean;		private var mov:MovieClip;		private var side:String;	private var switcheroo:Number;	private var travelled:Number;		private var startX:Number;	private var endX:Number;	private var mom:MovieClip;	private var tweenTime:Number;			function slideOut(){				var twn:Tween = new Tween(this.mov, "_x", Strong.easeOut, this.mov._x, this.startX, this.tweenTime, true);		this.doneSlide = false;				var thou:Trelement = this;				twn.onMotionFinished = function(){			thou.doneSlide = true;		}		}		function randRange(min:Number, max:Number):Number {		var randomNum:Number = Math.floor(Math.random() * (max - min + 1)) + min;		return randomNum;	}		function Trelement(_mom:MovieClip, _flavour:String, _dir:String, _city:String, _isExtra:Boolean, _num:Number){		var choices:Number;		var movName:String;		var stack:Number;		var maxDistance:Number;		var twn:Tween;				this.tweenTime = (this.randRange(1,3)/3) * 2;		this.doneSlide = true;				switch (_flavour){			case "top":			if (_city == "city"){				choices = 2;			} else {				choices = 2;			}			stack = 100000 + _num;			break;						case "tree":			if (_city == "city"){				choices = 3;			} else {				choices = 5;			}			if (_isExtra){				stack = 20000 + _num;			} else {				stack = 100 + _num;			}			break;						case "brush":			choices = 5;			stack = 10000 + _num;			break;						case "path":			if (_city == "city"){				choices = 3;			} else {				choices = 2;			}			stack = 1000 + _num;			break;		}				if ((_city == "city") && (_flavour != "brush")){			movName = "c" + _flavour;		} else {			movName = _flavour;		}				movName += ("_" + _dir + "_"+this.randRange(1,choices));				//trace("Dropping " + _flavour + " as "+movName+",  num:"+_num+",  extra:"+_isExtra);		//trace("actualDir:"+_dir+", actualCity:"+_city);		//trace("^^");		//trace("");				this.mov = _mom.attachMovie(movName, movName+"_"+_num, stack);		this.mov.mom = _mom._parent;						if ((_flavour == "tree") || (_flavour=="brush")){			this.mov._y = -this.randRange(-25,50);			this.mov._xscale = this.randRange(75,150);			this.mov._yscale = this.mov._xscale;			if (_flavour == "tree"){				this.mov.onRollOver = function(){					this.useHandCursor = false;
				}
			}		}					switch (_flavour){			case "path":			if (_dir=="left"){				this.startX =  -this.mov._width;				this.mov.dir = "L";							} else {				this.startX = Stage.width;				this.mov.dir = "R";			}						if (_mom._parent.forging){				maxDistance = this.mov._width - (_mom._parent.forgeDistance*(this.mov._width/_mom._parent.forgeMax));				trace("adjusting path forging to "+maxDistance);			} else {				maxDistance = this.mov._width;			}						break;						case "top":			if (_dir=="left"){				this.startX = -this.mov._width;			} else {				this.startX = Stage.width;			}			if ((movName.substr(-1,1) == "1")){				maxDistance = this.randRange(0, 150);			} else {				maxDistance = this.randRange(0, (Stage.width/2));			}			break;						default:			if (_dir=="left"){				this.startX = -this.mov._width;			} else {				this.startX = Stage.width;			}			maxDistance = this.randRange(0,(Stage.width/2));			break;		}				switch(_dir){			case "left":			this.endX = this.startX + maxDistance;			break;						case "right":			this.endX = this.startX - maxDistance;			break;					}			twn = new Tween(this.mov, "_x", Strong.easeOut, this.startX, this.endX, this.tweenTime, true);	}	}